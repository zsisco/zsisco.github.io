<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=10, user-scalable=yes">
<title>
Zachary D. Sisco
</title>
<style>
    body{
        margin: 1em auto;
        max-width: 800px;
        padding: 0.6em;
        font: 1.0em/1.6 sans-serif;
    }
    footer {
        text-align: right;
        margin-top: 80px;
        padding-bottom: 20px;
    }
    span.spam {
        display: none;
    }
</style>
<header id="top">
<h1>
Zachary D. Sisco
</h1>
<center>
<p>
<img src="assets/zach-campus-point.jpg" width="55%">
</p>
</center>
</header>
<p>I am an <a href="https://sds.cuhk.edu.cn/en/teacher/2233">Assistant
Professor</a> of Computer Science in the <a
href="https://sds.cuhk.edu.cn/en">School of Data Science</a> at the <a
href="https://cuhk.edu.cn/en">Chinese University of Hong Kong,
Shenzhen</a>. I completed my PhD at UC Santa Barbara, co-advised by <a
href="https://jbalkind.github.io/">Jonathan Balkind</a> and <a
href="https://sites.cs.ucsb.edu/~benh/">Ben Hardekopf</a>.</p>
<p>I conduct research at the intersection of <strong>Programming
Languages</strong> and <strong>Computer Architecture</strong>. My
research integrates formal methods into open-source languages for chip
design to increase developer agility with correctness guarantees.</p>
<p>I am looking for students! You can read my <a
href="#research-overview">research overview</a> for more information. If
you think we have mutual interests, please send me an email: <span
class="spam" aria-hidden="true">SPAM</span> <code>zsisco【at】</code>
<!-- qazwsxedcrfvtgbthnplmokjnibiuh -->
<code>cuhk「dot」edu《dot》cn</code></p>
<h3 id="conference-and-journal-publications">Conference and Journal
Publications</h3>
<ul>
<li><a href="papers/control-logic-synthesis.pdf">Control Logic
Synthesis: Drawing the Rest of the OWL</a> (ASPLOS 2024)<br />
<strong>Zachary D. Sisco</strong>, Andrew David Alex, Zechen Ma, Yeganeh
Aghamohammadi, Boming Kong, Benjamin Darnell, Timothy Sherwood, Ben
Hardekopf, Jonathan Balkind<br />
<a href="https://github.com/UCSBarchlab/owl">(Source code repo)</a></li>
<li><a href="papers/loop-rerolling-hw-decompilation.pdf">Loop Rerolling
for Hardware Decompilation</a> (PLDI 2023)<br />
<strong>Zachary D. Sisco</strong>, Jonathan Balkind, Timothy Sherwood,
Ben Hardekopf<br />
<a href="https://git.sr.ht/~zachs/hardware-loop-rerolling">(Source code
repo)</a></li>
<li><a
href="papers/semantics-based-approach-to-concept-assignment-in-assembly-code.pdf">A
semantics-based approach to concept assignment in assembly code</a>
(ICCWS 2017)<br />
<strong>Zachary D. Sisco</strong>, Adam Bryant</li>
<li><a
href="papers/modeling-information-flow_preprint_version-2.pdf">Modeling
information flow for an autonomous agent to support reverse engineering
work</a> (JDMS 2017)<br />
<strong>Zachary D. Sisco</strong>, Patrick Dudenhofer, Adam Bryant</li>
</ul>
<h3 id="workshop-papers">Workshop Papers</h3>
<ul>
<li><a href="papers/there-and-back-again.pdf">There and Back Again: A
Netlist’s Tale With Much Egraphin’</a> (LATTE 2024)<br />
Gus Henry Smith, <strong>Zachary D. Sisco</strong>, Thanawat
Techaumnuaiwit, Jingtao Xia, Vishal Canumalla, Andrew Cheung, Zachary
Tatlock, Chandrakana Nandi, Jonathan Balkind<br />
<a href="https://sampl.cs.washington.edu/churchroad-web-demo/">(Web
demo)</a></li>
<li><a href="papers/plarch23.pdf">Semi-Automated Translation of a Formal
ISA Specification to Hardware</a> (PLARCH 2023)<br />
Harlan Kringen, <strong>Zachary Sisco</strong>, Jonathan Balkind,
Timothy Sherwood, Ben Hardekopf</li>
<li>On the Generality of Matrix Multiplication (PLARCH 2023)<br />
Andrew Alex, <strong>Zachary D. Sisco</strong>, Jonathan Balkind</li>
<li><a
href="papers/a-position-on-program-synthesis-for-processor-development.pdf">A
Position on Program Synthesis for Processor Development</a> (LATTE
2022)<br />
<strong>Zachary D. Sisco</strong>, Jonathan Balkind, Timothy Sherwood,
Ben Hardekopf<br />
<a href="https://github.com/pllab/latte22-demo">(Source code
repo)</a></li>
</ul>
<h3 id="recorded-talks">Recorded Talks</h3>
<ul>
<li><a href="https://youtu.be/S1IA-8DxDIs">A Memory Design Language for
Automated Memory Technology Mapping</a> (May 2025)<br />
Latch-Up, Santa Barbara, CA.</li>
<li><a href="https://www.youtube.com/watch?v=LG0rHhfohFo">Loop Rerolling
for Hardware Decompilation</a> (June 2023)<br />
PLDI/FCRC 2023, Orlando, FL.</li>
<li><a href="https://youtu.be/FWPh26MOybg">A Position on Program
Synthesis for Processor Development</a> (March 2022)<br />
LATTE 2022 @ ASPLOS 2022, Lausanne, Switzerland / Virtual.</li>
</ul>
<h3 id="theses">Theses</h3>
<ul>
<li><a href="papers/sisco-dissertation.pdf">Automated Reasoning for
Agile and Robust Chip Design</a><br />
PhD Dissertation (UC Santa Barbara) 2025</li>
<li><a href="papers/sisco-zachary-thesis.pdf">Verifying data-oriented
gadgets in binary programs to build data-only exploits</a><br />
MS Thesis (Wright State University) 2018</li>
</ul>
<h3 id="random-bits">Random Bits</h3>
<ul>
<li><a href="papers/dusty.pdf">Formalizing a Consensus Protocol using
Dependent Session Types</a></li>
<li><a href="papers/Scheme2Beam.pdf">Scheme2Beam: A Source Compiler from
Scheme to Erlang</a></li>
<li><a href="papers/Separating_typed_Languages.pdf">Investigations into
a Separating-typed Language</a></li>
<li><a href="papers/conimp.pdf">Synthesizing Concurrent Code using a
Solver-aided DSL</a></li>
</ul>
<h1 id="research-overview">Research Overview</h1>
<p>The programming languages and tools used for chip design have not
kept pace with the growing complexity of these chips for emerging
applications. To handle these demands, and to enable newcomers to the
space with smaller teams and fewer resources, we need new approaches to
address the current state-of-the-art in chip development.</p>
<p>The research I conduct addresses 3 key challenges in chip design:</p>
<ol type="1">
<li><p><strong>Multilevel reasoning</strong>: The current chip
development process suffers from decoupling between all of the layers of
abstraction. Enormous effort goes into verification between the
specifications, models, and implementation—the difficulty being the
semantic gap between these layers. This disjointed process leads to long
design iterations, hindering agility and increasing verification
burden.</p></li>
<li><p><strong>Interoperability</strong>: The growth of new HDLs and
open-source hardware design tools adds new features that improve the
process of designing hardware over legacy languages and proprietary
tools. However, these new languages and tools often lack the ability the
interoperate, fragmenting the communities that use them and making
migration difficult, as manual porting is impractical. Limited
interoperability means that new HDLs cannot leverage the vast body of
existing designs written in legacy languages, and existing designs
cannot take advantage of the new features provided by these modern
tools.</p></li>
<li><p><strong>Technology constraints</strong>: Languages and tools for
chip design rely on technology-specific components, but lack helpful
abstractions needed to support common deployment platforms, making it
difficult to adapt and compose designs. Targeting platforms, such as
ASIC and FPGA, requires technology-specific code and so each new
technology being targeted requires updating an existing part of the code
with multiple independent descriptions of the same component.</p></li>
</ol>
<p>To address these challenges, my research integrates
<strong>automated-reasoning techniques</strong>, such as constraint
solvers and equational reasoning, into programming languages used for
chip design. These techniques improve developer agility and provide
formal guarantees about the design. For example:</p>
<ol type="1">
<li>Integrating constraint solvers (SMT) into languages for chip design
to enable program synthesis and correct-by-construction code
generation.</li>
<li>Using equational reasoning to transform designs into equivalent but
optimal representations.</li>
<li>Developing domain-specific languages (DSLs) which incorporate domain
models into languages for design tasks.</li>
</ol>
<h2 id="projects">Projects</h2>
<p>These projects tackle different aspects of the challenges outlined
above using automated-reasoning techniques.</p>
<h3 id="control-logic-synthesis">Control Logic Synthesis</h3>
<p><img style="float: right; max-width: 50%; margin-left: 5px; border:1px solid #000000" src="assets/restoftheowl.png">
Chip design requires reasoning between different layers of abstraction:
from an architectural specification (the instructions the chip
executes), to the microarchitectural datapath (the functional units),
down to the low-level control logic (which coordinates computation on
the chip). Implementing control logic itself is tedious and error-prone,
where changes at these levels propagate non-obvious changes to the
control. This work, published in <a
href="https://dl.acm.org/doi/10.1145/3622781.3674170">ASPLOS 2024</a>,
introduces a new technique, <strong>control logic synthesis</strong>,
which automatically generates conrrect-by-construction control logic for
a datapath according to a formal architectural specification.</p>
<p>The insight is adapting program synthesis techniques to HDLs,
bridging the gap between the datapath and the high-level specification—a
key direction we previously identified <a
href="papers/a-position-on-program-synthesis-for-processor-development.pdf">(LATTE
2022)</a>. Control logic synthesis allows chip developers to freely
modify and iterate over the designs of both the specification and the
datapath without getting caught up in the abstruse details of control,
as we show in case studies covering embedded-class RISC-V cores and
accelerators geared for cryptographic applications.</p>
<p>Future work will consider more control structures such as microcode
in the context of complex microarchitecture optimizations. There are
challenges ahead in terms of scaling automated reasoning techniques to
handle large, real-world chip implementations.</p>
<h3 id="hardware-decompilation">Hardware Decompilation</h3>
<p><img style="float: right; max-width: 30%; margin-left: 5px;" src="assets/z80-comp.png">
Imagine I handed you this chip. How could you know what’s inside it? To
date, hobbyists interested in this kind of computer archaeology take
photos of chips and apply machine learning to identify individual
components. But from there a new problem arises: how do you know what
that sea of components actually <em>means</em>? For instance, what if
you wanted to duplicate this chip? Or what if you wanted to recover the
code that produced the chip in the first place? This is the problem we
call <strong>hardware decompilation</strong>: Taking a digital circuit
like in this photo and recovering the high-level source code that can
reproduce it.</p>
<p>By the way, this photo is of the Z80, an 8-bit microprocessor made
around 1975. Chips nowadays could be made up of tens of
<em>billions</em> of components. Modern digital design is complex, and
chip designers have to analyze these enormous circuits, which is often a
bottle neck in the design process. This research not only helps
hobbyists reverse engineer vintage computers, hardware decompilation
enables new design tools for modern chip designers. Recovering structure
in digital circuits allows chip designers to analyze circuits faster and
with stronger correctness guarantees.</p>
<p>Our initial work in hardware decompilation focused on <a
href="https://dl.acm.org/doi/10.1145/3591237A">hardware loop
rerolling</a>, which is about finding repeated logic in circuits and
lifting it to loops in high-level HDL code. There are many more
programming abstractions to recover such as modules, state machines,
memory, etc., as well as applications for hardware decompilation to
improve the design process (such as automated technology
re-targeting).</p>
<h3 id="refinement-via-formal-specifications">Refinement via Formal
Specifications</h3>
<p>An open question for specification-driven chip development is: how to
refine an implementation from a spec? We are exploring methods for
deriving whole chip implementations from architectural specifications <a
href="papers/plarch23.pdf">(PLARCH 2023)</a>. The long-term goal is to
develop techniques that fully <em>derive</em> HDL code implementations
for entire chips from formal architectural specifications, where
compilation proceeds as a series of proof-carrying <em>refinements</em>
moving down the layers of abstraction from the architecture-level to the
microarchitecture, all the way to hardware.</p>
<h3 id="enriching-hardwaresoftware-interfaces">Enriching
Hardware–Software Interfaces</h3>
<p>Besides general-purpose computing, there are other aspects of the
hardware–software interface such as communication and data-movement
protocols and hardware accelerators that speed up specialized
computation and system services. The difficulty in using these
interfaces lies in the development process; current languages and
libraries do not provide the machinery to guide programmers to correctly
use them. Further, these interfaces run through the whole
hardware–software stack, encountering constraints through each layer.
Characterizing these interfaces as abstractions found in programming
language theory, we are developing new compilers that bridge the
hardware–software interface at these new frontiers to ensure correctness
of the use of—and even the automated synthesis of code using—these
interfaces through symbolic reasoning and constraint solvers. Our
previous work in control logic synthesis paves the way for exploring
these new interfaces, assisting the programmer in reasoning about
specialized hardware where they may have limited understanding.</p>
<h2 id="tips-for-prospective-students">Tips for Prospective
Students</h2>
<p>All of this research intersects with three areas: programming
languages, computer architecture, and formal methods. It is not required
or expected that you have familiarity with all of these areas. But you
should have an interest in at least one, and an openness to the
others.</p>
<p><a href="#top">Back to top ↑</a></p>
<footer>
This page is <a href="http://jeffhuang.com/designed_to_last/">designed
to last</a>.
</footer>
